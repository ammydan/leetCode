1、每次新元素入栈，栈内元素都保持有序（单调递增或者单调递减）
这个模板一般用来解决Next Greater Element问题。
时间复杂度为O(n)

vector<int> nextGreaterElement(vector<int>& nums) {
    vector<int> ans(nums.size()); // 存放答案的数组
    stack<int> s;
    for (int i = nums.size() - 1; i >= 0; i--) { // 倒着往栈里放
        while (!s.empty() && s.top() <= nums[i]) { // 判定个子高矮
            s.pop(); // 矮个起开，反正也被挡着了。。。
        }
        ans[i] = s.empty() ? -1 : s.top(); // 这个元素身后的第一个高个
        s.push(nums[i]); // 进队，接受之后的身高判定吧！
    }
    return ans;
}

2、快速记忆
①找比当前更大的元素（后面）维护一个递减单调栈，既可以顺着来，也可以逆着来。
推荐逆着来，这样不用再添加额外的遍历了。
②找比当前更大的元素（前面）维护一个递减单调栈，推荐顺着来。
③找比当前更小的元素（后面）维护一个递增单调栈，推荐逆着来。
④找比当前更小的元素（前面）维护一个递增单调栈，推荐顺着来。

3、题目中探索
①计算柱状图中最大的矩阵
这个题关键在于一个分类。
分类思想：按照给的数组的高度算出以这根柱子在这个位置的最大面积。
然后我们发现以这根柱子的高度扩展需要两侧大于或等于这个柱子，这个给了我们思路，按照从小到大的单调栈排，如果遇到比
栈顶小的说明以栈顶为高度的柱子已经到达了扩展的尽头（因为单调前面的柱子一定不大于这根柱子，那么相等了怎么办？没关系那前面一个计算一定会比我们大）
②接雨水

4、拓展（单调队列）
模板


